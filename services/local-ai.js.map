{"version":3,"file":"local-ai.js","sourceRoot":"","sources":["../src/services/local-ai.ts"],"names":[],"mappings":"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","sourcesContent":["let transcriber: any | undefined = undefined;\n\nself.onmessage = async (e) => {\n    if (e.data.type === 'transcribe') {\n        return new Promise((resolve) => {\n            console.log(\"in worker\", e.data)\n            localTranscribe(e.data.blob).then((transcription) => {\n                console.log(\"in worker\", transcription)\n                self.postMessage({\n                    type: 'transcribe',\n                    transcription: transcription\n                });\n                resolve(transcription);\n            })\n        })\n    }\n    else {\n        console.error('Unknown message type', e.data);\n        return Promise.reject('Unknown message type');\n    }\n}\n\nexport async function localTranscribe(audio: any): Promise<string> {\n    return new Promise(async (resolve) => {\n        if (!transcriber) {\n            const { pipeline, env } = await import('@xenova/transformers');\n            // @ts-ignore\n            env.allowLocalModels = false;\n            transcriber = await pipeline('automatic-speech-recognition', 'Xenova/whisper-base.en');\n        }\n\n        const output = await transcriber(audio, {\n            chunk_length_s: 30,\n            stride_length_s: 5,\n            callback_function: callback_function, // after each generation step\n            chunk_callback: chunk_callback, // after each chunk is processed\n        });\n        console.log('output', output);\n\n        resolve(output.text);\n    })\n}\n\n// Storage for chunks to be processed. Initialise with an empty chunk.\nlet chunks_to_process = [\n    {\n        tokens: [],\n        finalised: false,\n    },\n];\n\n// TODO: Storage for fully-processed and merged chunks\n// let decoded_chunks = [];\n\nfunction chunk_callback(chunk: any) {\n    let last = chunks_to_process[chunks_to_process.length - 1];\n\n    console.log(\"chunk_callback\", chunk)\n\n    // Overwrite last chunk with new info\n    Object.assign(last, chunk);\n    last.finalised = true;\n\n    // Create an empty chunk after, if it not the last chunk\n    if (!chunk.is_last) {\n        chunks_to_process.push({\n            tokens: [],\n            finalised: false,\n        });\n    }\n}\n\n// Inject custom callback function to handle merging of chunks\nfunction callback_function(item: any) {\n    const time_precision =\n        transcriber.processor.feature_extractor.config.chunk_length /\n        transcriber.model.config.max_source_positions;\n\n    let last: any = chunks_to_process[chunks_to_process.length - 1];\n\n    // Update tokens of last chunk\n    last.tokens = [...item[0].output_token_ids];\n\n    console.log(\"callback_function\", item, last)\n\n    // Merge text chunks\n    // TODO optimise so we don't have to decode all chunks every time\n    let data = transcriber.tokenizer._decode_asr(chunks_to_process, {\n        time_precision: time_precision,\n        return_timestamps: true,\n        force_full_sequences: false,\n    });\n\n    console.log(\"callback_function\", data);\n}"]}